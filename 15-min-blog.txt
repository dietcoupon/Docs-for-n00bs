This was assembled from the infamous 15-minute Rails blog screencast by Ryan Bates. It was a ridiculously fast 15 
minutes, and I found it pretty difficult to follow so I took the time to transcribe it. You can see the original 
screencast at http://media.rubyonrails.org/video/rails_blog_2.mov

It should also be noted that this was all done in Rails 2.2, which is kind of a thing of the past. If you happen to 
have the older Rails installed on your machine, this should work nicely for you. If all you have is Rails 3, what you 
see here is probably about 95% accurate, so be prepared for some debugging and call it good practice. If coding your 
own blog is akin to making your own light-saber, you're supposed to hit some snags along the way anyhow. Nothing 
ventured, nothing gained!

Anyway, let's get right on to it.

All good things begin in a new terminal window. Navigate to whichever folder you use for your programming shenanigans.

Enter 'rails blog' and lots of stuff will be created. Thanks, Rails! Enter 'cd blog' to go to the new directory.

We can always use 'ruby script/server' to host the application locally so we can check it in a browser to see what we 
have so far. It should be accessible at http://localhost:3000. At this point we'll just see the generic rails getting 
started page. To make the rest of this go smoothly, just keep the server running in a separate terminal window or tab.

Entering 'ruby script/generate scaffold Post title:string body:text' gives us the basic architecture for blog posts. We 
can apply this change to the blog application by using 'rake db:migrate'.

It's generally prudent to refresh the site in the browser whenever we run a migration. You'll see the generic rails 
page again if you just go to the localhost home page, so navigate to the /posts/ subdirectory to see what the schema 
actually generated. Apparently, we can create and edit posts.

Go to your text editor of choice and open the post.rb model (which can be found in the app folder). Add some validation 
near the top since we want every blog post to have substance:

  validates_presence_of :body, :title
  
There will be more than one place in the application where any given blog post is rendered, so we'll make a partial 
which can be accessed from anywhere to do just that. To do that, we're going to go to app/views/posts/ and make a 
new file starting with an underscore (in this case, _post.html.erb). Fill it with the necessary code:
    
    <% div_for post do %>
      <h2><%= link_to_unless_current h(post.title), post %> </h2>
      <%= simple_format h(post.body) %>
    <% end %>

For every post, then, it'll render the title with a link to the specific post in an <h2> up top and put the post itself
below it.
    
The first place we'll implement this code will be in the post show view file (show.html.erb, again in app/views/posts/), 
where we want to first access and use the partial, and then link to the various actions you can perform on any given post:
    
    <%= render :partial => @post %>
    
    <p>
      <%= link_to 'Edit', edit_post_path(@post) %> |
      <%= link_to 'Destroy', @post, :method => :delete, :confirm => "Are you sure?" %> |
      <%= link_to 'See All Posts', posts_path %>
    </p>
  
Note that Rails is smart enough to draw the connection between :partial => @post and _post.html.erb. We want to render 
the partial in the index file as well, so we replace almost all of that code (save for the link to a new post at the 
bottom) with the render partial code from above, changing @post to @posts since we want them all displayed.

To open up the ways in which we can interact with the application, we can fix it so as to accept input from coding 
languages besides ruby. We'll begin with xml. Return to the command prompt and enter: 'curl http://localhost:3000/posts.xml'. 
This returns the xml representation of our posts in the terminal window. If we go to the posts controller, we can see 
from the respond_to block that our application is now equipped to handle both html and xml. We can add as many other 
formats as we want by adding the relevant lines to that block of code. The next one we'll do is JSON for javascript 
functionality:

  format.json { render :json => @posts }
  
We go back to the terminal, rinse and repeat 'curl http://localhost:3000/posts.json', and we're good to go.

We also want add the .atom format to our respond_to block to enable a syndicate (RSS) feed:

  format.atom

Instead of using the render code, though, we have to add an index file. We do this by creating a new file: 
index.atom.builder (builder being the format we're going to use; it's good for building xml files). This file will be 
located in the views folder under posts. We add code to the file so as to loop through each post and build it for the 
RSS feed:

  atom_feed do |feed|
    feed.title("Blog Name!")
    feed.updated(@posts.first.created_at)
    
    @posts.each do |post|
      feed.entry(post) do |entry|
        entry.title(post.title)
        entry.content(post.body, :type => 'html')
        entry.author { |author| author.name("Tracy") }
      end
    end
  end
  
We can go back to the terminal and enter 'curl http://localhost:3000/posts.atom' if we want to see the code for the atom feed.

Now we go to the posts layout file (under views) and add code just beneath the stylesheet link to actually enable the feed:

  <%= auto_discovery_link_tag :atom, formatted_posts_path(:atom) %>
  
If we reload the site, we can finally see an RSS link that takes us to the atom feed.

Now we need some basic authentication since we don't want any given asshole to be able to edit our blog posts. We go 
back to the posts_controller and add some code to the top so as to add behavior before an action is called:

  before_filter :authenticate, :except => [:index, :show]
  
We then have to add a private section to the bottom of the code in order to add the authentication method called above:

  private
  
  def authenticate
    authenticate_or_request_with_http_basic do |name, password|
      name == "admin" && password == "secret"
    end
  end

Refresh the blog and try to edit a post to make sure the authentication works properly. You should get a pop-up window 
demanding a username and password. As you can see from the private authentication method, the username here will be 
'admin' with a password of 'secret', though of course you can change them to whatever you like, hopefully something 
more difficult to guess.

We now want to add commenting functionality, so get back to the command prompt. We'll generate a commenting model with 
a post_id column to link comments to a specific post, and a body to display text by entering 'ruby script/generate 
scaffold comment post_id:integer body:text'. As always, run the migration with 'rake db:migrate'.

Now that we have two models, we need to associate them with each other. Going into post.rb, after the validation, we add a line of code:
 
  has_many :comments
  
Going into comment.rb, we need to add a line to associate it to the post_id column:

  belongs_to :post
  
We want to cover our bases in the routes.rb file (in the config folder) as well. Alter the third line of code so it reads:

  map.resources :posts, :has_many => :comments

Comments are now nested inside of posts in the url, which just makes sense. We can see this in action by entering 'rake 
routes' in the command prompt. Since we want to list all of the comments for a given post on the post's page as well as 
a form for submitting new comments, we need to go to show.html.erb in app/views/posts/ and add some html to list the 
existing comments, as well as a form to submit a new comment:
  
  <h2>Comments</h2>
  <div id="comments">
    <%= render :partial => @post.comments %>
  </div>
  
  <% form_for [@post, Comment.new] do |f| %>
    <p>
    <%= f.label :body, "New Comment" %><br />
    <%= f.text_area :body %><br />
    </p>
    <p><%= f.submit "Add Comment" %></p>
  <% end %>
  
We can use @post.comments because comments is now given to us in the posts model (each post having many comments). We 
now need to create the comment partial in much the same way as we did for the posts, so we'll make a new file in 
app/views/comments/ called _comment.html.erb. It will, of course, contain code that renders out the comment:

  <% div_for comment do %>
    <p>
      <strong>Posted <%= time_ago_in_words(comment.created_at) %> ago</strong><br />
      <%= h(comment.body) %>
    </p>
  <% end %>
  
Reload the post page in the browser, looking for the Comments header and the form for new comments. The form won't work 
properly at this point since we haven't refined the comments controller yet. Scaffold did make one and give it a whole 
bunch of stuff that we can do, but we're only actually interested in creating comments. So, we'll get rid of everything 
between the first and last lines and build a relevant method from scratch:

  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.create!(params[:comment])
    redirect_to @post
  end
  
With the create method we fetch a post, add a new comment to that post, and redirect to the post page.

At this point we've implemented all of the functionality this tutorial will take us through. What remains is a bit of 
"fun" with javascript, as well as automated testing which every programmer really should be in the habit of doing, and 
doing well. If you care about those things, read on.

Maybe we want to add some ajax so that some javascript adds the comment to the page, refreshes it for us behind the 
scenes, and uses a cute little highlighting animation to display its addition. We add a line to the post layout file 
(directly under the auto discovery link tag) so as to include the necessary javascript files:

  <%= javascript_include_tag :all %>
  
We also need to alter one line in the comment form in the post show view file slightly so that it's submitted through 
ajax (remote_form_for instead of just form_for):

  <%= remote_form_for [@post, Comment.new] do |f| %>
  
Finally, we need to change the comment controller so it responds to the javascript. We add a respond_to block that 
contains the redirect functionality we already have with the html, but creates a template for javascript instead if it 
can:

  respond_to do |format|
    format.html { redirect_to @post }
    format.js
  end
  
We make a new file for the template in /views/comments: create.js.rjs (rjs means that the javascript is rendered using 
ruby). This file will have some code to insert the comment to the bottom of the comments div, highlight it, and reset 
the form:

  page.insert_html :bottom, :comments, :partial => @comment
  page[@comment].visual_effect :highlight
  page[:new_comment].reset
  
As always, we can go back to the browser and try it out. We don't actually need to reload the page because we're 
working with ajax. Without javascript enabled, we have the html fallback in place so everything still works just fine.

Since testing every little change in the browser gets to be a pain very quickly, we have the wonder that is automated 
testing. Rails even gives us a handy little directory for it. In the functional folder in the test directory, we can 
see a lot of testing for the comment controller already. Since we got rid of all the prefab methods in that controller, 
though, we can get rid of the tests for them as well. We'll replace them with some more relevant ones:

  class CommentsControllerTest < ActionController::TestCase
    test "should create comment and redirect to post without javascript" do
      p = Post.create!(:title => 'hello', :body => 'world')
      post :create, :post_id => p.id, :comment => { :body => 'nice!' }
      assert_redirected_to post_url(p)
      assert_equal 'nice!', p.comments.first.body
    end
    
    test "should create comment and render RJS template for ajax" do
      p = Post.create!(:title => 'hello', :body => 'world')
      post :create, :format => 'js', :post_id => p.id, :comment => { :body => 'nice!' }
      assert_template 'create.js.rjs'
      assert_equal 'nice!', p.comments.first.body
    end
  end
  
There are two separate tests here: one for normal html behavior, and one to check that the RJS template renders 
properly. Feel free to comment out the tests for the posts controller for now; they can be dealt with later.

Go back to the terminal window and run the 'rake test:functionals' command to actually execute the tests. The two 
periods between the 'Started' and 'Finished' show that both tests were run.

Congratulations! You should now have a functional blog. Note, however, that it is pretty ugly. If you can handle Ruby 
and Rails, CSS should be a piece of cake. Create a new file in public/stylesheets called stylesheet.css, and include 
(or adjust) the following code in app/views/posts.index.html.erb:

<%= stylesheet_link_tag "stylesheet" %>

Dive right on in to your new stylesheet and adjust the appearance to your liking. If you're not sure of yourself, check 
out www.w3schools.com/css/default.asp for some CSS tags and syntax. You can also poke through your blog's pre-existing 
scaffold.css file to get some ideas.

If we're bothering to make the blog pretty, we might want to be able to format the text of our posts as well. RedCloth 
is the standard Ruby Gem to accomplish this sort of thing. As well, you'll probably want to limit the number of posts 
that are loaded on every page. This is handled by the will_paginate gem. You can install these and include the 
dependencies at the top of your application_controller.rb file:

require "RedCloth"
require "will_paginate"

You might think about surfing through rubygems.org to find other nifty little libraries that will make your blog all 
the snazzier. You might even think about using Bundler to manage them when they become unwieldy.